// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature --include-generated-funcs
// RUN: %clang -x c++ -fompss-2 -Xclang -disable-llvm-passes %s -S -g -emit-llvm -o - | FileCheck %s
// expected-no-diagnostics
struct S {
    int x = 4;
    void foo() {
        #pragma oss task
        {
            x++;
            x++;
        }
    }
};

int main() {
    int x = 10;
    int vla[x];
    int array[10];
    S s;
    s.foo();
    x = vla[0] = array[0] = 43;
    #pragma oss task
    {
        x++;
        vla[0]++;
        array[0]++;
    }
}

// This test checks we reemit debug intrinsics again



// CHECK-LABEL: define {{[^@]+}}@main
// CHECK-SAME: () #[[ATTR0:[0-9]+]] !dbg [[DBG17:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[SAVED_STACK:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i64, align 8
// CHECK-NEXT:    [[ARRAY:%.*]] = alloca [10 x i32], align 16
// CHECK-NEXT:    [[S:%.*]] = alloca [[STRUCT_S:%.*]], align 4
// CHECK-NEXT:    call void @llvm.dbg.declare(metadata ptr [[X]], metadata [[META21:![0-9]+]], metadata !DIExpression()), !dbg [[DBG22:![0-9]+]]
// CHECK-NEXT:    store i32 10, ptr [[X]], align 4, !dbg [[DBG22]]
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[X]], align 4, !dbg [[DBG23:![0-9]+]]
// CHECK-NEXT:    [[TMP1:%.*]] = zext i32 [[TMP0]] to i64, !dbg [[DBG24:![0-9]+]]
// CHECK-NEXT:    [[TMP2:%.*]] = call ptr @llvm.stacksave(), !dbg [[DBG24]]
// CHECK-NEXT:    store ptr [[TMP2]], ptr [[SAVED_STACK]], align 8, !dbg [[DBG24]]
// CHECK-NEXT:    [[VLA:%.*]] = alloca i32, i64 [[TMP1]], align 16, !dbg [[DBG24]]
// CHECK-NEXT:    store i64 [[TMP1]], ptr [[__VLA_EXPR0]], align 8, !dbg [[DBG24]]
// CHECK-NEXT:    call void @llvm.dbg.declare(metadata ptr [[__VLA_EXPR0]], metadata [[META25:![0-9]+]], metadata !DIExpression()), !dbg [[DBG27:![0-9]+]]
// CHECK-NEXT:    call void @llvm.dbg.declare(metadata ptr [[VLA]], metadata [[META28:![0-9]+]], metadata !DIExpression()), !dbg [[DBG32:![0-9]+]]
// CHECK-NEXT:    call void @llvm.dbg.declare(metadata ptr [[ARRAY]], metadata [[META33:![0-9]+]], metadata !DIExpression()), !dbg [[DBG37:![0-9]+]]
// CHECK-NEXT:    call void @llvm.dbg.declare(metadata ptr [[S]], metadata [[META38:![0-9]+]], metadata !DIExpression()), !dbg [[DBG39:![0-9]+]]
// CHECK-NEXT:    call void @_ZN1SC2Ev(ptr noundef nonnull align 4 dereferenceable(4) [[S]]) #[[ATTR5:[0-9]+]], !dbg [[DBG39]]
// CHECK-NEXT:    call void @_ZN1S3fooEv(ptr noundef nonnull align 4 dereferenceable(4) [[S]]), !dbg [[DBG40:![0-9]+]]
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], ptr [[ARRAY]], i64 0, i64 0, !dbg [[DBG41:![0-9]+]]
// CHECK-NEXT:    store i32 43, ptr [[ARRAYIDX]], align 16, !dbg [[DBG42:![0-9]+]]
// CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds i32, ptr [[VLA]], i64 0, !dbg [[DBG43:![0-9]+]]
// CHECK-NEXT:    store i32 43, ptr [[ARRAYIDX1]], align 16, !dbg [[DBG44:![0-9]+]]
// CHECK-NEXT:    store i32 43, ptr [[X]], align 4, !dbg [[DBG45:![0-9]+]]
// CHECK-NEXT:    [[TMP3:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OSS"([5 x i8] c"TASK\00"), "QUAL.OSS.FIRSTPRIVATE"(ptr [[X]], i32 undef), "QUAL.OSS.FIRSTPRIVATE"(ptr [[VLA]], i32 undef), "QUAL.OSS.VLA.DIMS"(ptr [[VLA]], i64 [[TMP1]]), "QUAL.OSS.FIRSTPRIVATE"(ptr [[ARRAY]], [10 x i32] undef), "QUAL.OSS.CAPTURED"(i64 [[TMP1]]) ], !dbg [[DBG46:![0-9]+]]
// CHECK-NEXT:    call void @llvm.dbg.declare(metadata ptr [[X]], metadata [[META21]], metadata !DIExpression()), !dbg [[DBG22]]
// CHECK-NEXT:    call void @llvm.dbg.declare(metadata ptr [[VLA]], metadata [[META47:![0-9]+]], metadata !DIExpression()), !dbg [[DBG32]]
// CHECK-NEXT:    call void @llvm.dbg.declare(metadata ptr [[ARRAY]], metadata [[META33]], metadata !DIExpression()), !dbg [[DBG37]]
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[X]], align 4, !dbg [[DBG51:![0-9]+]]
// CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP4]], 1, !dbg [[DBG51]]
// CHECK-NEXT:    store i32 [[INC]], ptr [[X]], align 4, !dbg [[DBG51]]
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, ptr [[VLA]], i64 0, !dbg [[DBG53:![0-9]+]]
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[ARRAYIDX2]], align 16, !dbg [[DBG54:![0-9]+]]
// CHECK-NEXT:    [[INC3:%.*]] = add nsw i32 [[TMP5]], 1, !dbg [[DBG54]]
// CHECK-NEXT:    store i32 [[INC3]], ptr [[ARRAYIDX2]], align 16, !dbg [[DBG54]]
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [10 x i32], ptr [[ARRAY]], i64 0, i64 0, !dbg [[DBG55:![0-9]+]]
// CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[ARRAYIDX4]], align 16, !dbg [[DBG56:![0-9]+]]
// CHECK-NEXT:    [[INC5:%.*]] = add nsw i32 [[TMP6]], 1, !dbg [[DBG56]]
// CHECK-NEXT:    store i32 [[INC5]], ptr [[ARRAYIDX4]], align 16, !dbg [[DBG56]]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP3]]), !dbg [[DBG57:![0-9]+]]
// CHECK-NEXT:    [[TMP7:%.*]] = load ptr, ptr [[SAVED_STACK]], align 8, !dbg [[DBG58:![0-9]+]]
// CHECK-NEXT:    call void @llvm.stackrestore(ptr [[TMP7]]), !dbg [[DBG58]]
// CHECK-NEXT:    ret i32 0, !dbg [[DBG58]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN1SC2Ev
// CHECK-SAME: (ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]]) unnamed_addr #[[ATTR3:[0-9]+]] comdat align 2 !dbg [[DBG59:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @llvm.dbg.declare(metadata ptr [[THIS_ADDR]], metadata [[META61:![0-9]+]], metadata !DIExpression()), !dbg [[DBG63:![0-9]+]]
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[X:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], ptr [[THIS1]], i32 0, i32 0, !dbg [[DBG64:![0-9]+]]
// CHECK-NEXT:    store i32 4, ptr [[X]], align 4, !dbg [[DBG64]]
// CHECK-NEXT:    ret void, !dbg [[DBG65:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN1S3fooEv
// CHECK-SAME: (ptr noundef nonnull align 4 dereferenceable(4) [[THIS:%.*]]) #[[ATTR4:[0-9]+]] comdat align 2 !dbg [[DBG66:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @llvm.dbg.declare(metadata ptr [[THIS_ADDR]], metadata [[META67:![0-9]+]], metadata !DIExpression()), !dbg [[DBG68:![0-9]+]]
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OSS"([5 x i8] c"TASK\00"), "QUAL.OSS.SHARED"(ptr [[THIS1]], [[STRUCT_S:%.*]] undef) ], !dbg [[DBG69:![0-9]+]]
// CHECK-NEXT:    call void @llvm.dbg.declare(metadata ptr [[THIS1]], metadata [[META70:![0-9]+]], metadata !DIExpression()), !dbg [[DBG68]]
// CHECK-NEXT:    [[X:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[THIS1]], i32 0, i32 0, !dbg [[DBG71:![0-9]+]]
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[X]], align 4, !dbg [[DBG73:![0-9]+]]
// CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP1]], 1, !dbg [[DBG73]]
// CHECK-NEXT:    store i32 [[INC]], ptr [[X]], align 4, !dbg [[DBG73]]
// CHECK-NEXT:    [[X2:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[THIS1]], i32 0, i32 0, !dbg [[DBG74:![0-9]+]]
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[X2]], align 4, !dbg [[DBG75:![0-9]+]]
// CHECK-NEXT:    [[INC3:%.*]] = add nsw i32 [[TMP2]], 1, !dbg [[DBG75]]
// CHECK-NEXT:    store i32 [[INC3]], ptr [[X2]], align 4, !dbg [[DBG75]]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]), !dbg [[DBG76:![0-9]+]]
// CHECK-NEXT:    ret void, !dbg [[DBG77:![0-9]+]]
//
