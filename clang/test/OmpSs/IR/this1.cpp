// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature --include-generated-funcs
// RUN: %clang_cc1 -x c++ -verify -fompss-2 -disable-llvm-passes -ferror-limit 100 %s -S -emit-llvm -o - | FileCheck %s
// expected-no-diagnostics

// The purpose of this test is to check that, altough we
// need to capture 'this' as firstprivate in the task outline
// we do not need it when building compute_dep function/call

struct S {
  S() {}
  void foo(int a);
};

#pragma oss task in(*a)
void bar(int *a, S *s) {};

void S::foo(int a) {
  bar(&a, this);
}

int main() {
  S s;
}

// CHECK-LABEL: define {{[^@]+}}@_Z3barPiP1S
// CHECK-SAME: (ptr noundef [[A:%.*]], ptr noundef [[S:%.*]]) #[[ATTR0:[0-9]+]] !dbg [[DBG5:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[S_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    store ptr [[S]], ptr [[S_ADDR]], align 8
// CHECK-NEXT:    ret void, !dbg [[DBG9:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN1S3fooEi
// CHECK-SAME: (ptr noundef nonnull align 1 dereferenceable(1) [[THIS:%.*]], i32 noundef [[A:%.*]]) #[[ATTR0]] align 2 !dbg [[DBG10:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[CALL_ARG:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[CALL_ARG2:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    store ptr [[A_ADDR]], ptr [[CALL_ARG]], align 8, !dbg [[DBG11:![0-9]+]]
// CHECK-NEXT:    store ptr [[THIS1]], ptr [[CALL_ARG2]], align 8, !dbg [[DBG12:![0-9]+]]
// CHECK-NEXT:    [[TMP0:%.*]] = call token @llvm.directive.region.entry() [ "DIR.OSS"([5 x i8] c"TASK\00"), "QUAL.OSS.FIRSTPRIVATE"(ptr [[CALL_ARG]], ptr undef), "QUAL.OSS.FIRSTPRIVATE"(ptr [[CALL_ARG2]], ptr undef), "QUAL.OSS.DEP.IN"(ptr [[CALL_ARG]], [3 x i8] c"*a\00", ptr @compute_dep, ptr [[CALL_ARG]]), "QUAL.OSS.DECL.SOURCE"([9 x i8] c"bar:14:9\00") ], !dbg [[DBG13:![0-9]+]]
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[CALL_ARG]], align 8, !dbg [[DBG11]]
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[CALL_ARG2]], align 8, !dbg [[DBG12]]
// CHECK-NEXT:    call void @_Z3barPiP1S(ptr noundef [[TMP1]], ptr noundef [[TMP2]]), !dbg [[DBG13]]
// CHECK-NEXT:    call void @llvm.directive.region.exit(token [[TMP0]]), !dbg [[DBG13]]
// CHECK-NEXT:    ret void, !dbg [[DBG14:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@compute_dep
// CHECK-SAME: (ptr [[A:%.*]]) #[[ATTR2:[0-9]+]] !dbg [[DBG15:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT__DEPEND_UNPACK_T:%.*]], align 8
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A]], align 8, !dbg [[DBG16:![0-9]+]]
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds [[STRUCT__DEPEND_UNPACK_T]], ptr [[RETVAL]], i32 0, i32 0
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[TMP1]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds [[STRUCT__DEPEND_UNPACK_T]], ptr [[RETVAL]], i32 0, i32 1
// CHECK-NEXT:    store i64 4, ptr [[TMP2]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [[STRUCT__DEPEND_UNPACK_T]], ptr [[RETVAL]], i32 0, i32 2
// CHECK-NEXT:    store i64 0, ptr [[TMP3]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds [[STRUCT__DEPEND_UNPACK_T]], ptr [[RETVAL]], i32 0, i32 3
// CHECK-NEXT:    store i64 4, ptr [[TMP4]], align 8
// CHECK-NEXT:    [[TMP5:%.*]] = load [[STRUCT__DEPEND_UNPACK_T]], ptr [[RETVAL]], align 8, !dbg [[DBG16]]
// CHECK-NEXT:    ret [[STRUCT__DEPEND_UNPACK_T]] [[TMP5]], !dbg [[DBG16]]
//
//
// CHECK-LABEL: define {{[^@]+}}@main
// CHECK-SAME: () #[[ATTR3:[0-9]+]] !dbg [[DBG18:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[STRUCT_S:%.*]], align 1
// CHECK-NEXT:    call void @_ZN1SC1Ev(ptr noundef nonnull align 1 dereferenceable(1) [[S]]), !dbg [[DBG19:![0-9]+]]
// CHECK-NEXT:    ret i32 0, !dbg [[DBG20:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN1SC1Ev
// CHECK-SAME: (ptr noundef nonnull align 1 dereferenceable(1) [[THIS:%.*]]) unnamed_addr #[[ATTR4:[0-9]+]] comdat align 2 !dbg [[DBG21:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    call void @_ZN1SC2Ev(ptr noundef nonnull align 1 dereferenceable(1) [[THIS1]]), !dbg [[DBG22:![0-9]+]]
// CHECK-NEXT:    ret void, !dbg [[DBG23:![0-9]+]]
//
//
// CHECK-LABEL: define {{[^@]+}}@_ZN1SC2Ev
// CHECK-SAME: (ptr noundef nonnull align 1 dereferenceable(1) [[THIS:%.*]]) unnamed_addr #[[ATTR4]] comdat align 2 !dbg [[DBG24:![0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[THIS_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[THIS]], ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    [[THIS1:%.*]] = load ptr, ptr [[THIS_ADDR]], align 8
// CHECK-NEXT:    ret void, !dbg [[DBG25:![0-9]+]]
//
