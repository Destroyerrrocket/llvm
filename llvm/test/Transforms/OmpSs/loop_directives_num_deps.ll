; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt %s -ompss-2 -S | FileCheck %s
; ModuleID = 'loop_directives_num_deps.ll'
source_filename = "loop_directives_num_deps.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; void foo(int lb, int ub, int step) {
;     #pragma oss task for
;     for (int i = 0; i < 10; i += 1) {}
;     #pragma oss taskloop
;     for (int i = 0; i < 10; i += 1) {}
;     #pragma oss taskloop for
;     for (int i = 0; i < 10; i += 1) {}
; }

; Function Attrs: noinline nounwind optnone
define void @foo(i32 %lb, i32 %ub, i32 %step) #0 !dbg !6 {
; CHECK-LABEL: @foo(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[UB_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[STEP_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I1:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[I2:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[LB:%.*]], i32* [[LB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[UB:%.*]], i32* [[UB_ADDR]], align 4
; CHECK-NEXT:    store i32 [[STEP:%.*]], i32* [[STEP_ADDR]], align 4
; CHECK-NEXT:    store i32 0, i32* [[I]], align 4, [[DBG9:!dbg !.*]]
; CHECK-NEXT:    [[TMP0:%.*]] = alloca %nanos6_task_args_foo0*, align 8, [[DBG9]]
; CHECK-NEXT:    [[TMP1:%.*]] = alloca i8*, align 8, [[DBG9]]
; CHECK-NEXT:    [[NUM_DEPS:%.*]] = alloca i64, align 8, [[DBG9]]
; CHECK-NEXT:    [[TMP2:%.*]] = alloca %nanos6_task_args_foo1*, align 8, [[DBG10:!dbg !.*]]
; CHECK-NEXT:    [[TMP3:%.*]] = alloca i8*, align 8, [[DBG10]]
; CHECK-NEXT:    [[NUM_DEPS20:%.*]] = alloca i64, align 8, [[DBG10]]
; CHECK-NEXT:    [[TMP4:%.*]] = alloca %nanos6_task_args_foo2*, align 8, [[DBG11:!dbg !.*]]
; CHECK-NEXT:    [[TMP5:%.*]] = alloca i8*, align 8, [[DBG11]]
; CHECK-NEXT:    [[NUM_DEPS37:%.*]] = alloca i64, align 8, [[DBG11]]
; CHECK-NEXT:    br label [[FINAL_COND:%.*]], [[DBG9]]
; CHECK:       codeRepl:
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast %nanos6_task_args_foo0** [[TMP0]] to i8**, [[DBG9]]
; CHECK-NEXT:    store i64 0, i64* [[NUM_DEPS]], align 8, [[DBG9]]
; CHECK-NEXT:    [[TMP7:%.*]] = load i64, i64* [[NUM_DEPS]], align 8, [[DBG9]]
; CHECK-NEXT:    call void @nanos6_create_task(%nanos6_task_info_t* @task_info_var_foo0, %nanos6_task_invocation_info_t* @task_invocation_info_foo0, i64 16, i8** [[TMP6]], i8** [[TMP1]], i64 8, i64 [[TMP7]]), [[DBG9]]
; CHECK-NEXT:    [[TMP8:%.*]] = load %nanos6_task_args_foo0*, %nanos6_task_args_foo0** [[TMP0]], align 8, [[DBG9]]
; CHECK-NEXT:    [[TMP9:%.*]] = bitcast %nanos6_task_args_foo0* [[TMP8]] to i8*, [[DBG9]]
; CHECK-NEXT:    [[ARGS_END:%.*]] = getelementptr i8, i8* [[TMP9]], i64 16, [[DBG9]]
; CHECK-NEXT:    [[CAPT_GEP_:%.*]] = getelementptr [[NANOS6_TASK_ARGS_FOO0:%.*]], %nanos6_task_args_foo0* [[TMP8]], i32 0, i32 1, [[DBG9]]
; CHECK-NEXT:    store i32 0, i32* [[CAPT_GEP_]], align 4, [[DBG9]]
; CHECK-NEXT:    [[CAPT_GEP_6:%.*]] = getelementptr [[NANOS6_TASK_ARGS_FOO0]], %nanos6_task_args_foo0* [[TMP8]], i32 0, i32 2, [[DBG9]]
; CHECK-NEXT:    store i32 10, i32* [[CAPT_GEP_6]], align 4, [[DBG9]]
; CHECK-NEXT:    [[CAPT_GEP_7:%.*]] = getelementptr [[NANOS6_TASK_ARGS_FOO0]], %nanos6_task_args_foo0* [[TMP8]], i32 0, i32 3, [[DBG9]]
; CHECK-NEXT:    store i32 1, i32* [[CAPT_GEP_7]], align 4, [[DBG9]]
; CHECK-NEXT:    [[TMP10:%.*]] = load i8*, i8** [[TMP1]], align 8, [[DBG9]]
; CHECK-NEXT:    call void @nanos6_register_loop_bounds(i8* [[TMP10]], i64 0, i64 10, i64 0, i64 0), [[DBG9]]
; CHECK-NEXT:    call void @nanos6_submit_task(i8* [[TMP10]]), [[DBG9]]
; CHECK-NEXT:    br label [[FINAL_END:%.*]], [[DBG9]]
; CHECK:       final.end:
; CHECK-NEXT:    store i32 0, i32* [[I1]], align 4, [[DBG10]]
; CHECK-NEXT:    br label [[FINAL_COND12:%.*]], [[DBG10]]
; CHECK:       codeRepl17:
; CHECK-NEXT:    [[TMP11:%.*]] = bitcast %nanos6_task_args_foo1** [[TMP2]] to i8**, [[DBG10]]
; CHECK-NEXT:    store i64 0, i64* [[NUM_DEPS20]], align 8, [[DBG10]]
; CHECK-NEXT:    [[TMP12:%.*]] = load i64, i64* [[NUM_DEPS20]], align 8, [[DBG10]]
; CHECK-NEXT:    call void @nanos6_create_task(%nanos6_task_info_t* @task_info_var_foo1, %nanos6_task_invocation_info_t* @task_invocation_info_foo1, i64 16, i8** [[TMP11]], i8** [[TMP3]], i64 4, i64 [[TMP12]]), [[DBG10]]
; CHECK-NEXT:    [[TMP13:%.*]] = load %nanos6_task_args_foo1*, %nanos6_task_args_foo1** [[TMP2]], align 8, [[DBG10]]
; CHECK-NEXT:    [[TMP14:%.*]] = bitcast %nanos6_task_args_foo1* [[TMP13]] to i8*, [[DBG10]]
; CHECK-NEXT:    [[ARGS_END21:%.*]] = getelementptr i8, i8* [[TMP14]], i64 16, [[DBG10]]
; CHECK-NEXT:    [[CAPT_GEP_22:%.*]] = getelementptr [[NANOS6_TASK_ARGS_FOO1:%.*]], %nanos6_task_args_foo1* [[TMP13]], i32 0, i32 1, [[DBG10]]
; CHECK-NEXT:    store i32 0, i32* [[CAPT_GEP_22]], align 4, [[DBG10]]
; CHECK-NEXT:    [[CAPT_GEP_23:%.*]] = getelementptr [[NANOS6_TASK_ARGS_FOO1]], %nanos6_task_args_foo1* [[TMP13]], i32 0, i32 2, [[DBG10]]
; CHECK-NEXT:    store i32 10, i32* [[CAPT_GEP_23]], align 4, [[DBG10]]
; CHECK-NEXT:    [[CAPT_GEP_24:%.*]] = getelementptr [[NANOS6_TASK_ARGS_FOO1]], %nanos6_task_args_foo1* [[TMP13]], i32 0, i32 3, [[DBG10]]
; CHECK-NEXT:    store i32 1, i32* [[CAPT_GEP_24]], align 4, [[DBG10]]
; CHECK-NEXT:    [[TMP15:%.*]] = load i8*, i8** [[TMP3]], align 8, [[DBG10]]
; CHECK-NEXT:    call void @nanos6_register_loop_bounds(i8* [[TMP15]], i64 0, i64 10, i64 0, i64 0), [[DBG10]]
; CHECK-NEXT:    call void @nanos6_submit_task(i8* [[TMP15]]), [[DBG10]]
; CHECK-NEXT:    br label [[FINAL_END11:%.*]], [[DBG10]]
; CHECK:       final.end11:
; CHECK-NEXT:    store i32 0, i32* [[I2]], align 4, [[DBG11]]
; CHECK-NEXT:    br label [[FINAL_COND29:%.*]], [[DBG11]]
; CHECK:       codeRepl34:
; CHECK-NEXT:    [[TMP16:%.*]] = bitcast %nanos6_task_args_foo2** [[TMP4]] to i8**, [[DBG11]]
; CHECK-NEXT:    store i64 0, i64* [[NUM_DEPS37]], align 8, [[DBG11]]
; CHECK-NEXT:    [[TMP17:%.*]] = load i64, i64* [[NUM_DEPS37]], align 8, [[DBG11]]
; CHECK-NEXT:    call void @nanos6_create_task(%nanos6_task_info_t* @task_info_var_foo2, %nanos6_task_invocation_info_t* @task_invocation_info_foo2, i64 16, i8** [[TMP16]], i8** [[TMP5]], i64 12, i64 [[TMP17]]), [[DBG11]]
; CHECK-NEXT:    [[TMP18:%.*]] = load %nanos6_task_args_foo2*, %nanos6_task_args_foo2** [[TMP4]], align 8, [[DBG11]]
; CHECK-NEXT:    [[TMP19:%.*]] = bitcast %nanos6_task_args_foo2* [[TMP18]] to i8*, [[DBG11]]
; CHECK-NEXT:    [[ARGS_END38:%.*]] = getelementptr i8, i8* [[TMP19]], i64 16, [[DBG11]]
; CHECK-NEXT:    [[CAPT_GEP_39:%.*]] = getelementptr [[NANOS6_TASK_ARGS_FOO2:%.*]], %nanos6_task_args_foo2* [[TMP18]], i32 0, i32 1, [[DBG11]]
; CHECK-NEXT:    store i32 0, i32* [[CAPT_GEP_39]], align 4, [[DBG11]]
; CHECK-NEXT:    [[CAPT_GEP_40:%.*]] = getelementptr [[NANOS6_TASK_ARGS_FOO2]], %nanos6_task_args_foo2* [[TMP18]], i32 0, i32 2, [[DBG11]]
; CHECK-NEXT:    store i32 10, i32* [[CAPT_GEP_40]], align 4, [[DBG11]]
; CHECK-NEXT:    [[CAPT_GEP_41:%.*]] = getelementptr [[NANOS6_TASK_ARGS_FOO2]], %nanos6_task_args_foo2* [[TMP18]], i32 0, i32 3, [[DBG11]]
; CHECK-NEXT:    store i32 1, i32* [[CAPT_GEP_41]], align 4, [[DBG11]]
; CHECK-NEXT:    [[TMP20:%.*]] = load i8*, i8** [[TMP5]], align 8, [[DBG11]]
; CHECK-NEXT:    call void @nanos6_register_loop_bounds(i8* [[TMP20]], i64 0, i64 10, i64 0, i64 0), [[DBG11]]
; CHECK-NEXT:    call void @nanos6_submit_task(i8* [[TMP20]]), [[DBG11]]
; CHECK-NEXT:    br label [[FINAL_END28:%.*]], [[DBG11]]
; CHECK:       final.end28:
; CHECK-NEXT:    ret void, [[DBG12:!dbg !.*]]
; CHECK:       final.then:
; CHECK-NEXT:    store i32 0, i32* [[I]], align 4, [[DBG9]]
; CHECK-NEXT:    br label [[FOR_COND:%.*]], [[DBG9]]
; CHECK:       for.cond:
; CHECK-NEXT:    [[TMP21:%.*]] = load i32, i32* [[I]], align 4, [[DBG9]]
; CHECK-NEXT:    [[TMP22:%.*]] = icmp slt i32 [[TMP21]], 10, [[DBG9]]
; CHECK-NEXT:    br i1 [[TMP22]], label [[FOR_BODY:%.*]], label [[FINAL_END]], [[DBG9]]
; CHECK:       for.body:
; CHECK-NEXT:    br label [[FOR_INCR:%.*]], [[DBG10]]
; CHECK:       final.then13:
; CHECK-NEXT:    store i32 0, i32* [[I1]], align 4, [[DBG10]]
; CHECK-NEXT:    br label [[FOR_COND8:%.*]], [[DBG10]]
; CHECK:       for.cond8:
; CHECK-NEXT:    [[TMP23:%.*]] = load i32, i32* [[I1]], align 4, [[DBG10]]
; CHECK-NEXT:    [[TMP24:%.*]] = icmp slt i32 [[TMP23]], 10, [[DBG10]]
; CHECK-NEXT:    br i1 [[TMP24]], label [[FOR_BODY9:%.*]], label [[FINAL_END11]], [[DBG10]]
; CHECK:       for.body9:
; CHECK-NEXT:    br label [[FOR_INCR10:%.*]], [[DBG11]]
; CHECK:       final.then30:
; CHECK-NEXT:    store i32 0, i32* [[I2]], align 4, [[DBG11]]
; CHECK-NEXT:    br label [[FOR_COND25:%.*]], [[DBG11]]
; CHECK:       for.cond25:
; CHECK-NEXT:    [[TMP25:%.*]] = load i32, i32* [[I2]], align 4, [[DBG11]]
; CHECK-NEXT:    [[TMP26:%.*]] = icmp slt i32 [[TMP25]], 10, [[DBG11]]
; CHECK-NEXT:    br i1 [[TMP26]], label [[FOR_BODY26:%.*]], label [[FINAL_END28]], [[DBG11]]
; CHECK:       for.body26:
; CHECK-NEXT:    br label [[FOR_INCR27:%.*]], [[DBG12]]
; CHECK:       for.incr:
; CHECK-NEXT:    [[TMP27:%.*]] = load i32, i32* [[I]], align 4, [[DBG9]]
; CHECK-NEXT:    [[TMP28:%.*]] = add i32 [[TMP27]], 1, [[DBG9]]
; CHECK-NEXT:    store i32 [[TMP28]], i32* [[I]], align 4, [[DBG9]]
; CHECK-NEXT:    br label [[FOR_COND]], [[DBG9]]
; CHECK:       final.cond:
; CHECK-NEXT:    [[TMP29:%.*]] = call i32 @nanos6_in_final(), [[DBG9]]
; CHECK-NEXT:    [[TMP30:%.*]] = icmp ne i32 [[TMP29]], 0, [[DBG9]]
; CHECK-NEXT:    br i1 [[TMP30]], label [[FINAL_THEN:%.*]], label [[CODEREPL:%.*]], [[DBG9]]
; CHECK:       for.incr10:
; CHECK-NEXT:    [[TMP31:%.*]] = load i32, i32* [[I1]], align 4, [[DBG10]]
; CHECK-NEXT:    [[TMP32:%.*]] = add i32 [[TMP31]], 1, [[DBG10]]
; CHECK-NEXT:    store i32 [[TMP32]], i32* [[I1]], align 4, [[DBG10]]
; CHECK-NEXT:    br label [[FOR_COND8]], [[DBG10]]
; CHECK:       final.cond12:
; CHECK-NEXT:    [[TMP33:%.*]] = call i32 @nanos6_in_final(), [[DBG10]]
; CHECK-NEXT:    [[TMP34:%.*]] = icmp ne i32 [[TMP33]], 0, [[DBG10]]
; CHECK-NEXT:    br i1 [[TMP34]], label [[FINAL_THEN13:%.*]], label [[CODEREPL17:%.*]], [[DBG10]]
; CHECK:       for.incr27:
; CHECK-NEXT:    [[TMP35:%.*]] = load i32, i32* [[I2]], align 4, [[DBG11]]
; CHECK-NEXT:    [[TMP36:%.*]] = add i32 [[TMP35]], 1, [[DBG11]]
; CHECK-NEXT:    store i32 [[TMP36]], i32* [[I2]], align 4, [[DBG11]]
; CHECK-NEXT:    br label [[FOR_COND25]], [[DBG11]]
; CHECK:       final.cond29:
; CHECK-NEXT:    [[TMP37:%.*]] = call i32 @nanos6_in_final(), [[DBG11]]
; CHECK-NEXT:    [[TMP38:%.*]] = icmp ne i32 [[TMP37]], 0, [[DBG11]]
; CHECK-NEXT:    br i1 [[TMP38]], label [[FINAL_THEN30:%.*]], label [[CODEREPL34:%.*]], [[DBG11]]
;
entry:
  %lb.addr = alloca i32, align 4
  %ub.addr = alloca i32, align 4
  %step.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %i1 = alloca i32, align 4
  %i2 = alloca i32, align 4
  store i32 %lb, i32* %lb.addr, align 4
  store i32 %ub, i32* %ub.addr, align 4
  store i32 %step, i32* %step.addr, align 4
  store i32 0, i32* %i, align 4, !dbg !9
  %0 = call token @llvm.directive.region.entry() [ "DIR.OSS"([9 x i8] c"TASK.FOR\00"), "QUAL.OSS.PRIVATE"(i32* %i), "QUAL.OSS.LOOP.IND.VAR"(i32* %i), "QUAL.OSS.LOOP.LOWER.BOUND"(i32 0), "QUAL.OSS.LOOP.UPPER.BOUND"(i32 10), "QUAL.OSS.LOOP.STEP"(i32 1), "QUAL.OSS.LOOP.TYPE"(i64 0, i64 1, i64 1, i64 1, i64 1), "QUAL.OSS.CAPTURED"(i32 0, i32 10, i32 1) ], !dbg !9
  call void @llvm.directive.region.exit(token %0), !dbg !9
  store i32 0, i32* %i1, align 4, !dbg !10
  %1 = call token @llvm.directive.region.entry() [ "DIR.OSS"([9 x i8] c"TASKLOOP\00"), "QUAL.OSS.PRIVATE"(i32* %i1), "QUAL.OSS.LOOP.IND.VAR"(i32* %i1), "QUAL.OSS.LOOP.LOWER.BOUND"(i32 0), "QUAL.OSS.LOOP.UPPER.BOUND"(i32 10), "QUAL.OSS.LOOP.STEP"(i32 1), "QUAL.OSS.LOOP.TYPE"(i64 0, i64 1, i64 1, i64 1, i64 1), "QUAL.OSS.CAPTURED"(i32 0, i32 10, i32 1) ], !dbg !10
  call void @llvm.directive.region.exit(token %1), !dbg !10
  store i32 0, i32* %i2, align 4, !dbg !11
  %2 = call token @llvm.directive.region.entry() [ "DIR.OSS"([13 x i8] c"TASKLOOP.FOR\00"), "QUAL.OSS.PRIVATE"(i32* %i2), "QUAL.OSS.LOOP.IND.VAR"(i32* %i2), "QUAL.OSS.LOOP.LOWER.BOUND"(i32 0), "QUAL.OSS.LOOP.UPPER.BOUND"(i32 10), "QUAL.OSS.LOOP.STEP"(i32 1), "QUAL.OSS.LOOP.TYPE"(i64 0, i64 1, i64 1, i64 1, i64 1), "QUAL.OSS.CAPTURED"(i32 0, i32 10, i32 1) ], !dbg !11
  call void @llvm.directive.region.exit(token %2), !dbg !11
  ret void, !dbg !12
}

; Function Attrs: nounwind
declare token @llvm.directive.region.entry() #1

; Function Attrs: nounwind
declare void @llvm.directive.region.exit(token) #1

attributes #0 = { noinline nounwind optnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind }

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!3, !4}
!llvm.ident = !{!5}

!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "", isOptimized: false, runtimeVersion: 0, emissionKind: NoDebug, enums: !2, nameTableKind: None)
!1 = !DIFile(filename: "<stdin>", directory: "")
!2 = !{}
!3 = !{i32 2, !"Debug Info Version", i32 3}
!4 = !{i32 1, !"wchar_size", i32 4}
!5 = !{!"clang version 11.0.0 "}
!6 = distinct !DISubprogram(name: "foo", scope: !7, file: !7, line: 1, type: !8, scopeLine: 1, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)
!7 = !DIFile(filename: "loop_directives_num_deps.ll", directory: "")
!8 = !DISubroutineType(types: !2)
!9 = !DILocation(line: 3, scope: !6)
!10 = !DILocation(line: 5, scope: !6)
!11 = !DILocation(line: 7, scope: !6)
!12 = !DILocation(line: 8, scope: !6)
