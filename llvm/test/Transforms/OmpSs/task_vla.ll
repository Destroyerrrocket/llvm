; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt %s -ompss-2 -S | FileCheck %s
; ModuleID = 'task_vla.ll'
source_filename = "task_vla.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

; void pod_array(int n) {
;     int array[n];
;     #pragma oss task private(array)
;     {}
;     #pragma oss task firstprivate(array)
;     {}
; }
;
; struct S {
;     int x;
;     S();
;     S(const S&s);
;     ~S();
; };
;
; void non_pod_array(int n) {
;     S array[n];
;     #pragma oss task private(array)
;     {}
;     #pragma oss task firstprivate(array)
;     {}
; }

%struct.S = type { i32 }

define dso_local void @_Z9pod_arrayi(i32 %n) !dbg !6 {
; CHECK-LABEL: @_Z9pod_arrayi(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[N_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[SAVED_STACK:%.*]] = alloca i8*, align 8
; CHECK-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i64, align 8
; CHECK-NEXT:    store i32 [[N:%.*]], i32* [[N_ADDR]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* [[N_ADDR]], align 4, !dbg !8
; CHECK-NEXT:    [[TMP1:%.*]] = zext i32 [[TMP0]] to i64, !dbg !9
; CHECK-NEXT:    [[TMP2:%.*]] = call i8* @llvm.stacksave(), !dbg !9
; CHECK-NEXT:    store i8* [[TMP2]], i8** [[SAVED_STACK]], align 8, !dbg !9
; CHECK-NEXT:    [[VLA:%.*]] = alloca i32, i64 [[TMP1]], align 16, !dbg !9
; CHECK-NEXT:    store i64 [[TMP1]], i64* [[__VLA_EXPR0]], align 8, !dbg !9
; CHECK-NEXT:    br label [[FINAL_COND:%.*]], !dbg !10
; CHECK:       codeRepl:
; CHECK-NEXT:    [[TMP3:%.*]] = alloca %nanos6_task_args__Z9pod_arrayi0*, align 8, !dbg !10
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast %nanos6_task_args__Z9pod_arrayi0** [[TMP3]] to i8**, !dbg !10
; CHECK-NEXT:    [[TMP5:%.*]] = alloca i8*, align 8, !dbg !10
; CHECK-NEXT:    [[TMP6:%.*]] = mul nuw i64 4, [[TMP1]], !dbg !10
; CHECK-NEXT:    [[TMP7:%.*]] = add nuw i64 0, [[TMP6]], !dbg !10
; CHECK-NEXT:    [[TMP8:%.*]] = add nuw i64 16, [[TMP7]], !dbg !10
; CHECK-NEXT:    call void @nanos6_create_task(%nanos6_task_info_t* @task_info_var__Z9pod_arrayi0, %nanos6_task_invocation_info_t* @task_invocation_info__Z9pod_arrayi0, i64 [[TMP8]], i8** [[TMP4]], i8** [[TMP5]], i64 0, i64 0), !dbg !10
; CHECK-NEXT:    [[TMP9:%.*]] = load %nanos6_task_args__Z9pod_arrayi0*, %nanos6_task_args__Z9pod_arrayi0** [[TMP3]], align 8, !dbg !10
; CHECK-NEXT:    [[TMP10:%.*]] = bitcast %nanos6_task_args__Z9pod_arrayi0* [[TMP9]] to i8*, !dbg !10
; CHECK-NEXT:    [[ARGS_END:%.*]] = getelementptr i8, i8* [[TMP10]], i64 16, !dbg !10
; CHECK-NEXT:    [[GEP_VLA:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z9POD_ARRAYI0:%.*]], %nanos6_task_args__Z9pod_arrayi0* [[TMP9]], i32 0, i32 0, !dbg !10
; CHECK-NEXT:    [[TMP11:%.*]] = bitcast i32** [[GEP_VLA]] to i8**, !dbg !10
; CHECK-NEXT:    store i8* [[ARGS_END]], i8** [[TMP11]], align 4, !dbg !10
; CHECK-NEXT:    [[TMP12:%.*]] = mul nuw i64 4, [[TMP1]], !dbg !10
; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr i8, i8* [[ARGS_END]], i64 [[TMP12]], !dbg !10
; CHECK-NEXT:    [[CAPT_GEP_:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z9POD_ARRAYI0]], %nanos6_task_args__Z9pod_arrayi0* [[TMP9]], i32 0, i32 1, !dbg !10
; CHECK-NEXT:    store i64 [[TMP1]], i64* [[CAPT_GEP_]], align 8, !dbg !10
; CHECK-NEXT:    [[TMP14:%.*]] = load i8*, i8** [[TMP5]], align 8, !dbg !10
; CHECK-NEXT:    call void @nanos6_submit_task(i8* [[TMP14]]), !dbg !10
; CHECK-NEXT:    br label [[FINAL_END:%.*]], !dbg !10
; CHECK:       final.end:
; CHECK-NEXT:    br label [[FINAL_COND2:%.*]], !dbg !11
; CHECK:       codeRepl4:
; CHECK-NEXT:    [[TMP15:%.*]] = alloca %nanos6_task_args__Z9pod_arrayi1*, align 8, !dbg !11
; CHECK-NEXT:    [[TMP16:%.*]] = bitcast %nanos6_task_args__Z9pod_arrayi1** [[TMP15]] to i8**, !dbg !11
; CHECK-NEXT:    [[TMP17:%.*]] = alloca i8*, align 8, !dbg !11
; CHECK-NEXT:    [[TMP18:%.*]] = mul nuw i64 4, [[TMP1]], !dbg !11
; CHECK-NEXT:    [[TMP19:%.*]] = add nuw i64 0, [[TMP18]], !dbg !11
; CHECK-NEXT:    [[TMP20:%.*]] = add nuw i64 16, [[TMP19]], !dbg !11
; CHECK-NEXT:    call void @nanos6_create_task(%nanos6_task_info_t* @task_info_var__Z9pod_arrayi1, %nanos6_task_invocation_info_t* @task_invocation_info__Z9pod_arrayi1, i64 [[TMP20]], i8** [[TMP16]], i8** [[TMP17]], i64 0, i64 0), !dbg !11
; CHECK-NEXT:    [[TMP21:%.*]] = load %nanos6_task_args__Z9pod_arrayi1*, %nanos6_task_args__Z9pod_arrayi1** [[TMP15]], align 8, !dbg !11
; CHECK-NEXT:    [[TMP22:%.*]] = bitcast %nanos6_task_args__Z9pod_arrayi1* [[TMP21]] to i8*, !dbg !11
; CHECK-NEXT:    [[ARGS_END5:%.*]] = getelementptr i8, i8* [[TMP22]], i64 16, !dbg !11
; CHECK-NEXT:    [[GEP_VLA6:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z9POD_ARRAYI1:%.*]], %nanos6_task_args__Z9pod_arrayi1* [[TMP21]], i32 0, i32 0, !dbg !11
; CHECK-NEXT:    [[TMP23:%.*]] = bitcast i32** [[GEP_VLA6]] to i8**, !dbg !11
; CHECK-NEXT:    store i8* [[ARGS_END5]], i8** [[TMP23]], align 4, !dbg !11
; CHECK-NEXT:    [[TMP24:%.*]] = mul nuw i64 4, [[TMP1]], !dbg !11
; CHECK-NEXT:    [[TMP25:%.*]] = getelementptr i8, i8* [[ARGS_END5]], i64 [[TMP24]], !dbg !11
; CHECK-NEXT:    [[TMP26:%.*]] = mul nuw i64 1, [[TMP1]], !dbg !11
; CHECK-NEXT:    [[GEP_VLA7:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z9POD_ARRAYI1]], %nanos6_task_args__Z9pod_arrayi1* [[TMP21]], i32 0, i32 0, !dbg !11
; CHECK-NEXT:    [[TMP27:%.*]] = load i32*, i32** [[GEP_VLA7]], align 8, !dbg !11
; CHECK-NEXT:    [[TMP28:%.*]] = mul nuw i64 [[TMP26]], 4, !dbg !11
; CHECK-NEXT:    [[TMP29:%.*]] = bitcast i32* [[TMP27]] to i8*, !dbg !11
; CHECK-NEXT:    [[TMP30:%.*]] = bitcast i32* [[VLA]] to i8*, !dbg !11
; CHECK-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 [[TMP29]], i8* align 4 [[TMP30]], i64 [[TMP28]], i1 false), !dbg !11
; CHECK-NEXT:    [[CAPT_GEP_8:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z9POD_ARRAYI1]], %nanos6_task_args__Z9pod_arrayi1* [[TMP21]], i32 0, i32 1, !dbg !11
; CHECK-NEXT:    store i64 [[TMP1]], i64* [[CAPT_GEP_8]], align 8, !dbg !11
; CHECK-NEXT:    [[TMP31:%.*]] = load i8*, i8** [[TMP17]], align 8, !dbg !11
; CHECK-NEXT:    call void @nanos6_submit_task(i8* [[TMP31]]), !dbg !11
; CHECK-NEXT:    br label [[FINAL_END1:%.*]], !dbg !11
; CHECK:       final.end1:
; CHECK-NEXT:    [[TMP32:%.*]] = load i8*, i8** [[SAVED_STACK]], align 8, !dbg !12
; CHECK-NEXT:    call void @llvm.stackrestore(i8* [[TMP32]]), !dbg !12
; CHECK-NEXT:    ret void, !dbg !12
; CHECK:       final.then:
; CHECK-NEXT:    br label [[FINAL_END]], !dbg !11
; CHECK:       final.then3:
; CHECK-NEXT:    br label [[FINAL_END1]], !dbg !12
; CHECK:       final.cond:
; CHECK-NEXT:    [[TMP33:%.*]] = call i32 @nanos6_in_final(), !dbg !10
; CHECK-NEXT:    [[TMP34:%.*]] = icmp ne i32 [[TMP33]], 0, !dbg !10
; CHECK-NEXT:    br i1 [[TMP34]], label [[FINAL_THEN:%.*]], label [[CODEREPL:%.*]], !dbg !10
; CHECK:       final.cond2:
; CHECK-NEXT:    [[TMP35:%.*]] = call i32 @nanos6_in_final(), !dbg !11
; CHECK-NEXT:    [[TMP36:%.*]] = icmp ne i32 [[TMP35]], 0, !dbg !11
; CHECK-NEXT:    br i1 [[TMP36]], label [[FINAL_THEN3:%.*]], label [[CODEREPL4:%.*]], !dbg !11
;
entry:
  %n.addr = alloca i32, align 4
  %saved_stack = alloca i8*, align 8
  %__vla_expr0 = alloca i64, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load i32, i32* %n.addr, align 4, !dbg !8
  %1 = zext i32 %0 to i64, !dbg !9
  %2 = call i8* @llvm.stacksave(), !dbg !9
  store i8* %2, i8** %saved_stack, align 8, !dbg !9
  %vla = alloca i32, i64 %1, align 16, !dbg !9
  store i64 %1, i64* %__vla_expr0, align 8, !dbg !9
  %3 = call token @llvm.directive.region.entry() [ "DIR.OSS"([5 x i8] c"TASK\00"), "QUAL.OSS.PRIVATE"(i32* %vla), "QUAL.OSS.VLA.DIMS"(i32* %vla, i64 %1), "QUAL.OSS.CAPTURED"(i64 %1) ], !dbg !10
  call void @llvm.directive.region.exit(token %3), !dbg !11
  %4 = call token @llvm.directive.region.entry() [ "DIR.OSS"([5 x i8] c"TASK\00"), "QUAL.OSS.FIRSTPRIVATE"(i32* %vla), "QUAL.OSS.VLA.DIMS"(i32* %vla, i64 %1), "QUAL.OSS.CAPTURED"(i64 %1) ], !dbg !12
  call void @llvm.directive.region.exit(token %4), !dbg !13


  %5 = load i8*, i8** %saved_stack, align 8, !dbg !14
  call void @llvm.stackrestore(i8* %5), !dbg !14
  ret void, !dbg !14
}

define dso_local void @_Z13non_pod_arrayi(i32 %n) !dbg !15 {
; CHECK-LABEL: @_Z13non_pod_arrayi(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[N_ADDR:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[SAVED_STACK:%.*]] = alloca i8*, align 8
; CHECK-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i64, align 8
; CHECK-NEXT:    store i32 [[N:%.*]], i32* [[N_ADDR]], align 4
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* [[N_ADDR]], align 4, !dbg !14
; CHECK-NEXT:    [[TMP1:%.*]] = zext i32 [[TMP0]] to i64, !dbg !15
; CHECK-NEXT:    [[TMP2:%.*]] = call i8* @llvm.stacksave(), !dbg !15
; CHECK-NEXT:    store i8* [[TMP2]], i8** [[SAVED_STACK]], align 8, !dbg !15
; CHECK-NEXT:    [[VLA:%.*]] = alloca [[STRUCT_S:%.*]], i64 [[TMP1]], align 16, !dbg !15
; CHECK-NEXT:    store i64 [[TMP1]], i64* [[__VLA_EXPR0]], align 8, !dbg !15
; CHECK-NEXT:    [[ISEMPTY:%.*]] = icmp eq i64 [[TMP1]], 0, !dbg !16
; CHECK-NEXT:    br i1 [[ISEMPTY]], label [[ARRAYCTOR_CONT:%.*]], label [[NEW_CTORLOOP:%.*]], !dbg !16
; CHECK:       new.ctorloop:
; CHECK-NEXT:    [[ARRAYCTOR_END:%.*]] = getelementptr inbounds [[STRUCT_S]], %struct.S* [[VLA]], i64 [[TMP1]], !dbg !16
; CHECK-NEXT:    br label [[ARRAYCTOR_LOOP:%.*]], !dbg !16
; CHECK:       arrayctor.loop:
; CHECK-NEXT:    [[ARRAYCTOR_CUR:%.*]] = phi %struct.S* [ [[VLA]], [[NEW_CTORLOOP]] ], [ [[ARRAYCTOR_NEXT:%.*]], [[ARRAYCTOR_LOOP]] ], !dbg !16
; CHECK-NEXT:    call void @_ZN1SC1Ev(%struct.S* [[ARRAYCTOR_CUR]]), !dbg !16
; CHECK-NEXT:    [[ARRAYCTOR_NEXT]] = getelementptr inbounds [[STRUCT_S]], %struct.S* [[ARRAYCTOR_CUR]], i64 1, !dbg !16
; CHECK-NEXT:    [[ARRAYCTOR_DONE:%.*]] = icmp eq %struct.S* [[ARRAYCTOR_NEXT]], [[ARRAYCTOR_END]], !dbg !16
; CHECK-NEXT:    br i1 [[ARRAYCTOR_DONE]], label [[ARRAYCTOR_CONT]], label [[ARRAYCTOR_LOOP]], !dbg !16
; CHECK:       arrayctor.cont:
; CHECK-NEXT:    br label [[FINAL_COND:%.*]], !dbg !17
; CHECK:       codeRepl:
; CHECK-NEXT:    [[TMP3:%.*]] = alloca %nanos6_task_args__Z13non_pod_arrayi0*, align 8, !dbg !17
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast %nanos6_task_args__Z13non_pod_arrayi0** [[TMP3]] to i8**, !dbg !17
; CHECK-NEXT:    [[TMP5:%.*]] = alloca i8*, align 8, !dbg !17
; CHECK-NEXT:    [[TMP6:%.*]] = mul nuw i64 4, [[TMP1]], !dbg !17
; CHECK-NEXT:    [[TMP7:%.*]] = add nuw i64 0, [[TMP6]], !dbg !17
; CHECK-NEXT:    [[TMP8:%.*]] = add nuw i64 16, [[TMP7]], !dbg !17
; CHECK-NEXT:    call void @nanos6_create_task(%nanos6_task_info_t* @task_info_var__Z13non_pod_arrayi0, %nanos6_task_invocation_info_t* @task_invocation_info__Z13non_pod_arrayi0, i64 [[TMP8]], i8** [[TMP4]], i8** [[TMP5]], i64 0, i64 0), !dbg !17
; CHECK-NEXT:    [[TMP9:%.*]] = load %nanos6_task_args__Z13non_pod_arrayi0*, %nanos6_task_args__Z13non_pod_arrayi0** [[TMP3]], align 8, !dbg !17
; CHECK-NEXT:    [[TMP10:%.*]] = bitcast %nanos6_task_args__Z13non_pod_arrayi0* [[TMP9]] to i8*, !dbg !17
; CHECK-NEXT:    [[ARGS_END:%.*]] = getelementptr i8, i8* [[TMP10]], i64 16, !dbg !17
; CHECK-NEXT:    [[GEP_VLA:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z13NON_POD_ARRAYI0:%.*]], %nanos6_task_args__Z13non_pod_arrayi0* [[TMP9]], i32 0, i32 0, !dbg !17
; CHECK-NEXT:    [[TMP11:%.*]] = bitcast %struct.S** [[GEP_VLA]] to i8**, !dbg !17
; CHECK-NEXT:    store i8* [[ARGS_END]], i8** [[TMP11]], align 8, !dbg !17
; CHECK-NEXT:    [[TMP12:%.*]] = mul nuw i64 4, [[TMP1]], !dbg !17
; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr i8, i8* [[ARGS_END]], i64 [[TMP12]], !dbg !17
; CHECK-NEXT:    [[TMP14:%.*]] = mul nuw i64 1, [[TMP1]], !dbg !17
; CHECK-NEXT:    [[GEP_VLA1:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z13NON_POD_ARRAYI0]], %nanos6_task_args__Z13non_pod_arrayi0* [[TMP9]], i32 0, i32 0, !dbg !17
; CHECK-NEXT:    [[TMP15:%.*]] = load %struct.S*, %struct.S** [[GEP_VLA1]], align 8, !dbg !17
; CHECK-NEXT:    call void @oss_ctor_ZN1SC1Ev(%struct.S* [[TMP15]], i64 [[TMP14]]), !dbg !17
; CHECK-NEXT:    [[CAPT_GEP_:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z13NON_POD_ARRAYI0]], %nanos6_task_args__Z13non_pod_arrayi0* [[TMP9]], i32 0, i32 1, !dbg !17
; CHECK-NEXT:    store i64 [[TMP1]], i64* [[CAPT_GEP_]], align 8, !dbg !17
; CHECK-NEXT:    [[TMP16:%.*]] = load i8*, i8** [[TMP5]], align 8, !dbg !17
; CHECK-NEXT:    call void @nanos6_submit_task(i8* [[TMP16]]), !dbg !17
; CHECK-NEXT:    br label [[FINAL_END:%.*]], !dbg !17
; CHECK:       final.end:
; CHECK-NEXT:    br label [[FINAL_COND3:%.*]], !dbg !18
; CHECK:       codeRepl5:
; CHECK-NEXT:    [[TMP17:%.*]] = alloca %nanos6_task_args__Z13non_pod_arrayi1*, align 8, !dbg !18
; CHECK-NEXT:    [[TMP18:%.*]] = bitcast %nanos6_task_args__Z13non_pod_arrayi1** [[TMP17]] to i8**, !dbg !18
; CHECK-NEXT:    [[TMP19:%.*]] = alloca i8*, align 8, !dbg !18
; CHECK-NEXT:    [[TMP20:%.*]] = mul nuw i64 4, [[TMP1]], !dbg !18
; CHECK-NEXT:    [[TMP21:%.*]] = add nuw i64 0, [[TMP20]], !dbg !18
; CHECK-NEXT:    [[TMP22:%.*]] = add nuw i64 16, [[TMP21]], !dbg !18
; CHECK-NEXT:    call void @nanos6_create_task(%nanos6_task_info_t* @task_info_var__Z13non_pod_arrayi1, %nanos6_task_invocation_info_t* @task_invocation_info__Z13non_pod_arrayi1, i64 [[TMP22]], i8** [[TMP18]], i8** [[TMP19]], i64 0, i64 0), !dbg !18
; CHECK-NEXT:    [[TMP23:%.*]] = load %nanos6_task_args__Z13non_pod_arrayi1*, %nanos6_task_args__Z13non_pod_arrayi1** [[TMP17]], align 8, !dbg !18
; CHECK-NEXT:    [[TMP24:%.*]] = bitcast %nanos6_task_args__Z13non_pod_arrayi1* [[TMP23]] to i8*, !dbg !18
; CHECK-NEXT:    [[ARGS_END6:%.*]] = getelementptr i8, i8* [[TMP24]], i64 16, !dbg !18
; CHECK-NEXT:    [[GEP_VLA7:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z13NON_POD_ARRAYI1:%.*]], %nanos6_task_args__Z13non_pod_arrayi1* [[TMP23]], i32 0, i32 0, !dbg !18
; CHECK-NEXT:    [[TMP25:%.*]] = bitcast %struct.S** [[GEP_VLA7]] to i8**, !dbg !18
; CHECK-NEXT:    store i8* [[ARGS_END6]], i8** [[TMP25]], align 8, !dbg !18
; CHECK-NEXT:    [[TMP26:%.*]] = mul nuw i64 4, [[TMP1]], !dbg !18
; CHECK-NEXT:    [[TMP27:%.*]] = getelementptr i8, i8* [[ARGS_END6]], i64 [[TMP26]], !dbg !18
; CHECK-NEXT:    [[TMP28:%.*]] = mul nuw i64 1, [[TMP1]], !dbg !18
; CHECK-NEXT:    [[GEP_VLA8:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z13NON_POD_ARRAYI1]], %nanos6_task_args__Z13non_pod_arrayi1* [[TMP23]], i32 0, i32 0, !dbg !18
; CHECK-NEXT:    [[TMP29:%.*]] = load %struct.S*, %struct.S** [[GEP_VLA8]], align 8, !dbg !18
; CHECK-NEXT:    call void @oss_copy_ctor_ZN1SC1ERKS_(%struct.S* [[VLA]], %struct.S* [[TMP29]], i64 [[TMP28]]), !dbg !18
; CHECK-NEXT:    [[CAPT_GEP_9:%.*]] = getelementptr [[NANOS6_TASK_ARGS__Z13NON_POD_ARRAYI1]], %nanos6_task_args__Z13non_pod_arrayi1* [[TMP23]], i32 0, i32 1, !dbg !18
; CHECK-NEXT:    store i64 [[TMP1]], i64* [[CAPT_GEP_9]], align 8, !dbg !18
; CHECK-NEXT:    [[TMP30:%.*]] = load i8*, i8** [[TMP19]], align 8, !dbg !18
; CHECK-NEXT:    call void @nanos6_submit_task(i8* [[TMP30]]), !dbg !18
; CHECK-NEXT:    br label [[FINAL_END2:%.*]], !dbg !18
; CHECK:       final.end2:
; CHECK-NEXT:    [[TMP31:%.*]] = getelementptr inbounds [[STRUCT_S]], %struct.S* [[VLA]], i64 [[TMP1]], !dbg !19
; CHECK-NEXT:    [[ARRAYDESTROY_ISEMPTY:%.*]] = icmp eq %struct.S* [[VLA]], [[TMP31]], !dbg !19
; CHECK-NEXT:    br i1 [[ARRAYDESTROY_ISEMPTY]], label [[ARRAYDESTROY_DONE1:%.*]], label [[ARRAYDESTROY_BODY:%.*]], !dbg !19
; CHECK:       arraydestroy.body:
; CHECK-NEXT:    [[ARRAYDESTROY_ELEMENTPAST:%.*]] = phi %struct.S* [ [[TMP31]], [[FINAL_END2]] ], [ [[ARRAYDESTROY_ELEMENT:%.*]], [[ARRAYDESTROY_BODY]] ], !dbg !19
; CHECK-NEXT:    [[ARRAYDESTROY_ELEMENT]] = getelementptr inbounds [[STRUCT_S]], %struct.S* [[ARRAYDESTROY_ELEMENTPAST]], i64 -1, !dbg !19
; CHECK-NEXT:    call void @_ZN1SD1Ev(%struct.S* [[ARRAYDESTROY_ELEMENT]]), !dbg !19
; CHECK-NEXT:    [[ARRAYDESTROY_DONE:%.*]] = icmp eq %struct.S* [[ARRAYDESTROY_ELEMENT]], [[VLA]], !dbg !19
; CHECK-NEXT:    br i1 [[ARRAYDESTROY_DONE]], label [[ARRAYDESTROY_DONE1]], label [[ARRAYDESTROY_BODY]], !dbg !19
; CHECK:       arraydestroy.done1:
; CHECK-NEXT:    [[TMP32:%.*]] = load i8*, i8** [[SAVED_STACK]], align 8, !dbg !19
; CHECK-NEXT:    call void @llvm.stackrestore(i8* [[TMP32]]), !dbg !19
; CHECK-NEXT:    ret void, !dbg !19
; CHECK:       final.then:
; CHECK-NEXT:    br label [[FINAL_END]], !dbg !18
; CHECK:       final.then4:
; CHECK-NEXT:    br label [[FINAL_END2]], !dbg !19
; CHECK:       final.cond:
; CHECK-NEXT:    [[TMP33:%.*]] = call i32 @nanos6_in_final(), !dbg !17
; CHECK-NEXT:    [[TMP34:%.*]] = icmp ne i32 [[TMP33]], 0, !dbg !17
; CHECK-NEXT:    br i1 [[TMP34]], label [[FINAL_THEN:%.*]], label [[CODEREPL:%.*]], !dbg !17
; CHECK:       final.cond3:
; CHECK-NEXT:    [[TMP35:%.*]] = call i32 @nanos6_in_final(), !dbg !18
; CHECK-NEXT:    [[TMP36:%.*]] = icmp ne i32 [[TMP35]], 0, !dbg !18
; CHECK-NEXT:    br i1 [[TMP36]], label [[FINAL_THEN4:%.*]], label [[CODEREPL5:%.*]], !dbg !18
;
entry:
  %n.addr = alloca i32, align 4
  %saved_stack = alloca i8*, align 8
  %__vla_expr0 = alloca i64, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load i32, i32* %n.addr, align 4, !dbg !16
  %1 = zext i32 %0 to i64, !dbg !17
  %2 = call i8* @llvm.stacksave(), !dbg !17
  store i8* %2, i8** %saved_stack, align 8, !dbg !17
  %vla = alloca %struct.S, i64 %1, align 16, !dbg !17
  store i64 %1, i64* %__vla_expr0, align 8, !dbg !17
  %isempty = icmp eq i64 %1, 0, !dbg !18
  br i1 %isempty, label %arrayctor.cont, label %new.ctorloop, !dbg !18

new.ctorloop:                                     ; preds = %entry
  %arrayctor.end = getelementptr inbounds %struct.S, %struct.S* %vla, i64 %1, !dbg !18
  br label %arrayctor.loop, !dbg !18

arrayctor.loop:                                   ; preds = %arrayctor.loop, %new.ctorloop
  %arrayctor.cur = phi %struct.S* [ %vla, %new.ctorloop ], [ %arrayctor.next, %arrayctor.loop ], !dbg !18
  call void @_ZN1SC1Ev(%struct.S* %arrayctor.cur), !dbg !18
  %arrayctor.next = getelementptr inbounds %struct.S, %struct.S* %arrayctor.cur, i64 1, !dbg !18
  %arrayctor.done = icmp eq %struct.S* %arrayctor.next, %arrayctor.end, !dbg !18
  br i1 %arrayctor.done, label %arrayctor.cont, label %arrayctor.loop, !dbg !18

arrayctor.cont:                                   ; preds = %entry, %arrayctor.loop
  %3 = call token @llvm.directive.region.entry() [ "DIR.OSS"([5 x i8] c"TASK\00"), "QUAL.OSS.PRIVATE"(%struct.S* %vla), "QUAL.OSS.VLA.DIMS"(%struct.S* %vla, i64 %1), "QUAL.OSS.INIT"(%struct.S* %vla, void (%struct.S*, i64)* @oss_ctor_ZN1SC1Ev), "QUAL.OSS.DEINIT"(%struct.S* %vla, void (%struct.S*, i64)* @oss_dtor_ZN1SD1Ev), "QUAL.OSS.CAPTURED"(i64 %1) ], !dbg !19
  call void @llvm.directive.region.exit(token %3), !dbg !20
  %4 = call token @llvm.directive.region.entry() [ "DIR.OSS"([5 x i8] c"TASK\00"), "QUAL.OSS.FIRSTPRIVATE"(%struct.S* %vla), "QUAL.OSS.VLA.DIMS"(%struct.S* %vla, i64 %1), "QUAL.OSS.COPY"(%struct.S* %vla, void (%struct.S*, %struct.S*, i64)* @oss_copy_ctor_ZN1SC1ERKS_), "QUAL.OSS.DEINIT"(%struct.S* %vla, void (%struct.S*, i64)* @oss_dtor_ZN1SD1Ev), "QUAL.OSS.CAPTURED"(i64 %1) ], !dbg !21
  call void @llvm.directive.region.exit(token %4), !dbg !22


  %5 = getelementptr inbounds %struct.S, %struct.S* %vla, i64 %1, !dbg !23
  %arraydestroy.isempty = icmp eq %struct.S* %vla, %5, !dbg !23
  br i1 %arraydestroy.isempty, label %arraydestroy.done1, label %arraydestroy.body, !dbg !23

arraydestroy.body:                                ; preds = %arraydestroy.body, %arrayctor.cont
  %arraydestroy.elementPast = phi %struct.S* [ %5, %arrayctor.cont ], [ %arraydestroy.element, %arraydestroy.body ], !dbg !23
  %arraydestroy.element = getelementptr inbounds %struct.S, %struct.S* %arraydestroy.elementPast, i64 -1, !dbg !23
  call void @_ZN1SD1Ev(%struct.S* %arraydestroy.element) #1, !dbg !23
  %arraydestroy.done = icmp eq %struct.S* %arraydestroy.element, %vla, !dbg !23
  br i1 %arraydestroy.done, label %arraydestroy.done1, label %arraydestroy.body, !dbg !23

arraydestroy.done1:                               ; preds = %arraydestroy.body, %arrayctor.cont
  %6 = load i8*, i8** %saved_stack, align 8, !dbg !23
  call void @llvm.stackrestore(i8* %6), !dbg !23
  ret void, !dbg !23
}

; CHECK: define internal void @nanos6_unpacked_destroy__Z13non_pod_arrayi0(%struct.S* %vla, i64 %0) {
; CHECK: entry:
; CHECK-NEXT:   %1 = mul nuw i64 1, %0
; CHECK-NEXT:   call void @oss_dtor_ZN1SD1Ev(%struct.S* %vla, i64 %1)
; CHECK-NEXT:   ret void
; CHECK-NEXT: }

; CHECK: define internal void @nanos6_unpacked_destroy__Z13non_pod_arrayi1(%struct.S* %vla, i64 %0) {
; CHECK: entry:
; CHECK-NEXT:   %1 = mul nuw i64 1, %0
; CHECK-NEXT:   call void @oss_dtor_ZN1SD1Ev(%struct.S* %vla, i64 %1)
; CHECK-NEXT:   ret void
; CHECK-NEXT: }

declare i8* @llvm.stacksave()
declare token @llvm.directive.region.entry()
declare void @llvm.directive.region.exit(token)
declare void @llvm.stackrestore(i8*)
declare dso_local void @_ZN1SC1Ev(%struct.S*)
declare dso_local void @oss_ctor_ZN1SC1Ev(%struct.S* %0, i64 %1)
declare dso_local void @_ZN1SD1Ev(%struct.S*)
declare dso_local void @oss_dtor_ZN1SD1Ev(%struct.S* %0, i64 %1)
declare dso_local void @_ZN1SC1ERKS_(%struct.S*, %struct.S* dereferenceable(4))
declare dso_local void @oss_copy_ctor_ZN1SC1ERKS_(%struct.S* %0, %struct.S* %1, i64 %2)

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!3, !4}
!llvm.ident = !{!5}

!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_14, file: !1, producer: "human", isOptimized: false, runtimeVersion: 0, emissionKind: NoDebug, enums: !2, nameTableKind: None)
!1 = !DIFile(filename: "task_vla.ll", directory: "llvm/test/Transforms/OmpSs")
!2 = !{}
!3 = !{i32 2, !"Debug Info Version", i32 3}
!4 = !{i32 1, !"wchar_size", i32 4}
!5 = !{!""}
!6 = distinct !DISubprogram(name: "pod_array", scope: !1, file: !1, line: 1, type: !7, scopeLine: 1, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)
!7 = !DISubroutineType(types: !2)
!8 = !DILocation(line: 2, column: 15, scope: !6)
!9 = !DILocation(line: 2, column: 5, scope: !6)
!10 = !DILocation(line: 3, column: 13, scope: !6)
!11 = !DILocation(line: 4, column: 6, scope: !6)
!12 = !DILocation(line: 5, column: 13, scope: !6)
!13 = !DILocation(line: 6, column: 6, scope: !6)
!14 = !DILocation(line: 7, column: 1, scope: !6)
!15 = distinct !DISubprogram(name: "non_pod_array", scope: !1, file: !1, line: 16, type: !7, scopeLine: 16, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)
!16 = !DILocation(line: 17, column: 13, scope: !15)
!17 = !DILocation(line: 17, column: 5, scope: !15)
!18 = !DILocation(line: 17, column: 7, scope: !15)
!19 = !DILocation(line: 18, column: 13, scope: !15)
!20 = !DILocation(line: 19, column: 6, scope: !15)
!21 = !DILocation(line: 20, column: 13, scope: !15)
!22 = !DILocation(line: 21, column: 6, scope: !15)
!23 = !DILocation(line: 22, column: 1, scope: !15)

